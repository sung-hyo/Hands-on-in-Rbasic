---
title: "R 실습 자료 1차"
subtitle: "기초 사용법"
output: html_notebook
---

# 대입 연산자
대인 연산자(assignment operator)는 일반적으로 오른쪽에 기재된 부분을 실행하고 그 결과를 대입연산자가 가리키는 객체에 할당(저장)하는 일을 한다. 

R에서 대입연산자는 "<-" 또는 "="를 이용하는데 "<-" 와 "->"의 경우 화살표가 가르키는 방향으로 실행 결과를 반환한다. 

```{r}
value_one <- 1
value_one
```

R의 경우 반대방향으로 실행이 가능하나 일반적으로 사용하지 않는 방법이다. 
```{r}
1 -> value_one
value_one
```

대입연산자를 등호 "="를 이용하는 경우에는 하면 오른쪽의 연산을 왼쪽의 value_one 이름의 변수에 저장한다. 
```{r}
value_one = 1
value_one
```

그럼 같다를 의미하는 연산자는 등호 두개를 연속해서 `==`를 사용한다. 
아래 문장을 실행하면 value_one에 저장된 값이 1과 같은가를 물어보는 문장으로 반환 결과는 TRUE 또는 FALSE이다. 
```{r}
value_one == 1
```

<hr style="border:1px solid black">

# 값의 입력과 자료형 확인
R의 경우 기본적으로 저장하는 값의 자료형을 보고 자동적으로 변수의 자료형을 결정한다. 

---

## 숫자형

### 실수
정수를 저장하면 자동으로 실수형으로 지정이 된다. 
```{r}
value_numeric <- 1
print(value_numeric) #객체를 출력하기 위한 print() 함수 호출
typeof(value_numeric) #객체의 자료형을 확인하기 위한 typeof() 함수 호출
```

#### 함수
- `print()` 함수는 R에 내장된 기본함수로 `()` 괄호 안에 기재된 내용을 출력해주는 일을 한다. 
- 이름 뒤에 `()`가 오면 이 이름은 함수의 이름이다. 
- 접두어 `is.`이 오면 점뒤에 오는 단어의 뜻이 맞는가를 물어보는 함수이다. 
- 접두어 `as.`가 오면 `~로`의 뜻으로 점뒤에 오는 단어의 뜻으로 바꾸겠다는 함수이다.
```{r}
is.numeric(value_numeric)
is.double(value_numeric)
```

```{r}
value_numericToint <- as.integer(value_numeric) #실수를 정수로 바꾼다.
is.double(value_numericToint)
print(value_numericToint)
```

### 정수
```{r}
value_int <- integer(1)
typeof(value_int)
```

```{r}
value_int <- 1L
typeof(value_int)
```

---

## 논리형
```{r}
value_logical <- TRUE
print(value_logical)
typeof(value_logical)
```

```{r}
value_logical <- FALSE
typeof(value_logical)
```

R에서 논리형 값인 TRUE와 FALSE는 대문자료 표기한다.
아래와 같이 입력할 경우 오류 메세지를 반환한다. 

```{r, error=T}
value_logical <-True
```

---

## 문자열
문자열은 항상 따옴표('') 또는 쌍따옴표(/"/")로 감싸야 한다. 
따옴표로 감싸지 읺은 문자열은 특정 객체의 이름으로 인식하게 된다. 

*문자열*은 문자의 열(a sequence of characters)이라고 하면 수의 열(a sequence of numbers)인 수열과 유사하다. 
컴퓨터는 문자를 이진수로 변환하여 저장하고, 저장된 이진수를 다시 문자로 변환하여 화면에 나타낸다. 
문자를 이진수로 변환하는 것을 암호화(encoding)라고 하고 이진수를 다시 문자로 변환하는 것을 복호화(decoding)라고 한다.
R은 아스키(American Standard Code for Information Interchange, ASCII)를 사용하기 때문에 R에서 문자열은 아스키의 열이다. 

```{r}
value_str <- 'Hello'
print(value_str)
typeof(value_str)
```

문자열의 아스키 값을 확인하기 위해 `charToraw()`함수를 이용해서 변환해서 결과를 확인한다. 
```{r}
value_str <- 'Hello'
# 문자열을 raw로 변환하는 함수를 이용하여 반환 결과를 확인
# 문자열의 ASCII 값을 반환한다. 
charToRaw(value_str) 
```

문자열은 여러 개의 문자를 순서대로 저장하는 일종의 자료구조이다. 
따라서 문자의 순서에 접근할 수 있으나 R에서는 인덱스를 이용해서 접근하지 않고 함수나 `stringr` 패키지를 이용해서 문자열을 다룰 수 있다. 
여기서 문자열은 다루지 않겠지만 이러한 기능이 있다는 정도로 확인하면 된다. 

```{r}
value_str <- 'Hello'

#슬라이싱(slicing) 연속적인 객체의 범위를 지정해서 객체를 가져오는 방법
substr(value_str, 1, 1) #1번째 인덱스에서 1개의 값을 추출
substr(value_str, 1, 2) #1번째 인덱스에서 2개의 값을 추출
```
```{r}
strsplit(value_str, "")
```

<hr style="border:1px solid black">

# 벡터(vector)
R에서 하나이 상의 값을 저장하기 위한 객체로 벡터를 지원한다. 
`vector()` 함수를 호출할 때 mode 인자에 "numeric", "interger", "logical", "character", "complex" 5개의 문자열 중 하나를 값으로 전달하여 지정하고 이때 인자는 따옴표로 감싸서 문자열로 전달해야 한다. 
그리고 length에는 몇개의 값을 저장할 것인가에 대해서 값을 주면 된다. 
```{r}
# 5명의 성별을 저장하기 위해 gender 변수를 생성한다. 
gender <- vector(mode = 'character', length = 5)
print(gender)
length(gender) # 벡터에 저장된 원소의 갯수를 확인하기 위해 length() 함수를 호출
```

벡터는 인덱스를 가지고 있기 때문에 익덱스에 접근해서 값을 저장한다. 
```{r}
gender <- vector(mode = 'character', length = 5)

gender[1] <- "M"
gender[2] <- "M"
gender[3] <- "F"
gender[4] <- "F"
gender[5] <- gender[4] # genders의 4번째 인덱스 값을 불러와서 5번째에 저장
print(gender)
```

변수의 값을 저장할 벡터 객체를 생성하기 위해 `vector()` 함수 대신 `numeric()`, `interger()`, `logical()`, `character()`, `complex()` 함수를 사용할 수 있다.
```{r}
weight <- numeric()
print(weight)

weight[1] <- 62.0
weight[2] <- 62.9
weight[3] <- 36.1
weight[4] <- 54.6
weight[5] <- 48.5
print(weight)
```

rate 라는 변수를 숫자 벡터로 선언하고 값을 아래와 같이 입력한다. 
3번째 값을 문자로 입력하게 되면 어떻게 되는지 확인해 본다. 
```{r}
rate <- numeric()
rate[1] <- 1792
rate[2] <- 1666
rate[3] <- '995' #문자로 저장한다면...
rate[4] <- 1425
rate[5] <- 1396
str(rate) # 객체의 구조를 확인하기 위해 str() 함수를 호출
```
rate의 자료형이 문자로 바뀌어 있음을 확인할 수 있다. 
하나의 벡터는 동일한 자료형의 값들을 포함해야 한다. 
오류로 판단되지만 R에서 자동으로 자료형을 변경한다. 

이렇게 숫자형이 문자형으로 지정되는 경우 `as.numeric()`이나 `as.integer()` 함수를 이용해서 자료형을 변경한다. 
```{r}
rate_int <- as.integer(rate)
str(rate_int)
```

---

### 객체 관리
객체 목록을 확인하기 위해 `ls()` 함수를 이용한다. 
```{r}
ls()
```
객체를 지우기 위해서 `rm()`이용한다. 
```{r}
rm(gender) # 객체 gender를 삭제
ls() # 객체 목록을 확인
```

*Rstudio*를 이용하면 환경 패널에서 관리가 가능하다. 

---

## 간단히 벡터 만들기
위에 방법은 고전적인 방법으로 벡터 객체의 각 공간에 값을 하나씩 저장하는 방법을 사용하였다. 
하지만 저장할 값의 개수가 많을 경우 이 방법은 상당히 불편하다. 
한꺼번에 여러 개의 값을 벡터 객체에 저장하거나, 자료의 일부분이 저장된 여러 백터 객체를 묶어서 하나의 벡터 객체로 만드는 방법이 필요하다. 
이런 용도로 사용할 수 있는 함수가 `c()`함수이다. 
본래 `c()`함수는 여러 개의 객체를 하나의 객체로 통합해주는 함수인데, R은 값 하나 하나도 객체로 취급하기 때문에 여러 개의 값을 한꺼번에 입력할 때도 사용할 수 있다. 

`c()`함수의 인자로 여러 개의 값을 한꺼번에 입력할 때 쉼표 ','로 구분한다. 
```{r}
gender.one <- c("M", "M")
gender.two <- c("F", "F", "F")
gender <- c(gender.one, gender.two)
weight <- c(62.0, 62.9, 36.1, 54.6, 48.5)
rate <- c(1792, 1666, 995, 1425, 1396)
print(gender.one)
print(gender.two)
print(gender)
```

### 일정 간격의 숫자로 구성된 벡터 만들기
등차수열을 생성하는 `seq()` 함수를 사용하면 일정 간격의 숫자로 구성된 벡터를 만들 수 있다. 
`seq()` 함수를 호출할 때는 from, to, by, length 인자에 초항, 마지막 항, 공차, 수열 길이를 전달하면 된다. 
4가지 모두에 값을 전달할 필요는 없다.
도움말을 확인하기 위해 `help()` 함수를 호출해서 `seq()` 함수를 확인해 본다. 
```{r}
help(seq)
```

여러가지 방법을 이용해서 확인해 본다. 
```{r}
seq_one <- seq(from=2, to=10, by=1)
print(seq_one)
seq_two <- seq(2, 10, 2)
print(seq_two)
```
반복적인 작업이나 연속된 값이 필요할 경우에 `seq()`함수를 호출하는 경우가 있다.

<hr style="border:1px solid black">

# 변수의 척도를 처리하는 방법
변수를 척도에 따라 분류하는 이유는 어떤 척도를 갖느냐에 따라 분석방법이 달라지기 때문이다. 
올바른 분석을 하기 위해서는 변수의 척도를 판단하고, 이를 입력한 자료에 반영하여야 한다. 

R에서 벡터 객체를 생성하고 그 객체에 변수의 값을 입력한다고 해서 R이 자동적으로 해당 변수의 척도를 알아내지는 못한다. 
따라서 벡터 객체에 자료를 입력하기 전이나 후에 변수의 척도와 관련된 적절한 조치를 취해야만 한다. 
특히 범주형 변수(명목척도, 순위척도)를 갖는 변수는 몇개의 한정된 값만 가질 수 있을 뿐 아니라 각 값이 특정한 집단을 나타내거나 정도를 나타낼때가 많다. 
따라서 범주형 변수의 경우 벡터 객체에 변수의 값을 입력한 다음 척도를 지정하여 타당하지 않은 연산이 실행되지 않도록 하여야 한다. 

성별을 나타내는 gender라는 변수의 척도는 명목 척도이며 남자와 여자를 나타내는 "M"과 "F" 두가지 값만 가질 수 있다. 
gender 객체에 "M"과 "F"를 입력하기 때문에 R은 gender 벡터 객체를 문자열로 저장한 객체로 인식할 것이고, 그 결과 "M"이나 "F"가 아닌 다른 문자열도 저장할 수 있다. 

명목 척도나 순위 척도를 가지는 변수의 값을 저장할 벡터 객체에 대해서는 이 벡터 객체에 저장할 수 있는 값과 각 값의 의미를 명시하는 것이 바람직한다. 
이런 목적으로 사용할 수 잇는 함수가 `factor()`이다. 
`factor()`를 호출할 때 값이 저장된 객체와 함께 추가로 levels, labels, ordered 인자의 값을 전달하여 척도와 관련된 사항을 명시한다. 
인자 levels에는 변수가 가질 수 있는 값이 들어 있는 벡터 객체를, 인자 labels에는 levels 인자에 지정된 각 값에 부여할 이름이 들어 있는 벡터 객체를, ordered 인자에는 명목척도인지 순위척도인지를 논리값 TRUE, FALSE로(또는 T, F) 지정한다. 

```{r}
gender <- c("M", "M", "F", "F", "F")
str(gender)
```

```{r}
gender_right <- factor(gender, levels=c("M","F"),
                       labels=c("male", "female"), ordered=F)
is.factor(gender_right)
str(gender_right)
```

```{r}
print(gender_right)
```

`factor()`함수에서 levels로 정의되지 않은 값을 입력할 경우에 오류를 반환한다. 
```{r, error=T}
gender_right[6] <- "f"
```

출력해서 확인해 보면 변수가 가질 수 없는 값 소문주 **f**는 결측을 의미하는 **NA**가 된다. 
```{r}
print(gender_right)
```
  
> **NA**는 Not Available 줄임말로 사용할 수 없는이며, 결측값을 의미한다. **NaN**는 Not a Number의 줄임말로 정의 되지 않거나 할 수 없는 결과를 수학 연산으로 나타내는데 사용한다. **NULL** 은 대부분 언어에서 대상이 없다는 의미이다. **inf**는 infinite의 줄임말로 무한대를 나타낸다. 





